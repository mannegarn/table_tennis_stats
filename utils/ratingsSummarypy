import pandas as pd
import glicko2
from tqdm import tqdm
import numpy as np
import math

def calculate_ratings_history(players_df, matches_df, info_string: str = ""):
    
    """
    Calculates Glicko-2 ratings by iterating chronologically through all matches.
    Uses NumPy pre-allocation for significantly faster processing.
    
    Args:
        players_df (pd.DataFrame): DataFrame containing at least 'playerId'.
        matches_df (pd.DataFrame): DataFrame with 'matchDate', 'winnerId', 'loserId', 
                                     'documentCode', 'dnf', 'Winner', 'winnerName', 
                                     'loserName', 'winnerCountry', 'loserCountry', 'EventName'.
        info_string (str, optional): A string to append to all non-metadata (data) columns. 
                                     Defaults to "".

    Returns:
        pd.DataFrame: A new DataFrame with match ratings (pre and post and delta) for every match.
    """

    print(f"--- ðŸŸ¢ Commencing Glicko-2 Rating Calculation ({info_string or 'Default'}) ðŸŸ¢---")
    
    # 1. Initialize the player "cache"
    print("Initializing player rating cache...")
    player_cache = {
        int(row.playerId): {
            'glicko_obj': glicko2.Player(),
            'match_count': 0
        }
        for row in players_df.itertuples()
    }
    print(f"âœ… Cache initialized for {len(player_cache)} players.")

    sorted_matches_df = matches_df.sort_values('matchDate')
    
    dnf_filter_bool = sorted_matches_df['dnf'] == False
    dnf_filter_str = sorted_matches_df['dnf'] == 'False'
    dnf_mask = dnf_filter_bool | dnf_filter_str
    
    matches_to_rate_df = sorted_matches_df[dnf_mask].copy() 
    
    matches_to_rate_df = matches_to_rate_df.dropna(subset=['winnerId', 'loserId'])

    num_matches_to_rate = len(matches_to_rate_df)
    num_original_matches = len(matches_df)

    print(f"ðŸ“ {num_matches_to_rate} matches to rate out of {num_original_matches} total matches. ðŸ“")

    # --- 2. Initialize ratings_history (Original column names) ---
    ratings_history = {
        # --- METADATA COLUMNS (NOW STANDALONE) ---
        'eventId': np.empty(num_matches_to_rate, dtype=int),
        'EventName': np.empty(num_matches_to_rate, dtype=object),
        'documentCode': np.empty(num_matches_to_rate, dtype=object),
        'matchDate': np.empty(num_matches_to_rate, dtype=object),
        'winnerId': np.empty(num_matches_to_rate, dtype=int),
        'winnerName': np.empty(num_matches_to_rate, dtype=object),
        'winnerCountry': np.empty(num_matches_to_rate, dtype=object),
        'loserId': np.empty(num_matches_to_rate, dtype=int),
        'loserName': np.empty(num_matches_to_rate, dtype=object),
        'loserCountry': np.empty(num_matches_to_rate, dtype=object),
        'Winner': np.empty(num_matches_to_rate, dtype=object),
        
        # --- PRE-MATCH RATINGS ---
        'winner_rating_pre': np.empty(num_matches_to_rate, dtype=float),
        'winner_rd_pre': np.empty(num_matches_to_rate, dtype=float),
        'winner_vol_pre': np.empty(num_matches_to_rate, dtype=float),
        'loser_rating_pre': np.empty(num_matches_to_rate, dtype=float),
        'loser_rd_pre': np.empty(num_matches_to_rate, dtype=float),
        'loser_vol_pre': np.empty(num_matches_to_rate, dtype=float),
        
        # --- POST-MATCH RATINGS ---
        'winner_rating_post': np.empty(num_matches_to_rate, dtype=float),
        'loser_rating_post': np.empty(num_matches_to_rate, dtype=float),
        'winner_rd_post': np.empty(num_matches_to_rate, dtype=float),
        'loser_rd_post': np.empty(num_matches_to_rate, dtype=float),
        
        # --- DELTA & ANALYSIS COLUMNS ---
        'winner_rating_delta': np.empty(num_matches_to_rate, dtype=float),
        'loser_rating_delta': np.empty(num_matches_to_rate, dtype=float),
        'rating_difference_pre': np.empty(num_matches_to_rate, dtype=float), 
        'expected_outcome': np.empty(num_matches_to_rate, dtype=float),
        
        # --- MATCH COUNT COLUMNS ---
        'winner_matches_played': np.empty(num_matches_to_rate, dtype=int),
        'loser_matches_played': np.empty(num_matches_to_rate, dtype=int),
    }

    # --- 3. Main Loop (Unaltered, populates with original names) ---
    for i, row in enumerate(tqdm(matches_to_rate_df.itertuples(index=False), total=num_matches_to_rate)):
        try:
            winner_id = int(row.winnerId)
            loser_id = int(row.loserId)

            winner_cache_entry = player_cache[winner_id]
            loser_cache_entry = player_cache[loser_id]
            
            winner_obj = winner_cache_entry['glicko_obj']
            loser_obj = loser_cache_entry['glicko_obj']

            winner_rating_pre = winner_obj.rating
            loser_rating_pre = loser_obj.rating
            
            rating_difference = loser_rating_pre - winner_rating_pre
            expected_win_chance = 1 / (1 + math.pow(10, rating_difference / 400))
            
            match_outcome = getattr(row, "Winner", None) 

            # --- Store All Columns ---
            ratings_history['eventId'][i] = row.eventId
            ratings_history['EventName'][i] = row.EventName 
            ratings_history['documentCode'][i] = row.documentCode
            ratings_history['matchDate'][i] = row.matchDate
            ratings_history['winnerId'][i] = winner_id 
            ratings_history['winnerName'][i] = row.winnerName
            ratings_history['winnerCountry'][i] = row.winnerCountry
            ratings_history['loserId'][i] = loser_id 
            ratings_history['loserName'][i] = row.loserName
            ratings_history['loserCountry'][i] = row.loserCountry
            ratings_history['Winner'][i] = match_outcome
            
            ratings_history['winner_rating_pre'][i] = winner_rating_pre
            ratings_history['winner_rd_pre'][i] = winner_obj.rd
            ratings_history['winner_vol_pre'][i] = winner_obj.vol
            ratings_history['loser_rating_pre'][i] = loser_rating_pre
            ratings_history['loser_rd_pre'][i] = loser_obj.rd
            ratings_history['loser_vol_pre'][i] = loser_obj.vol

            ratings_history['rating_difference_pre'][i] = winner_rating_pre - loser_rating_pre
            ratings_history['expected_outcome'][i] = expected_win_chance

            if match_outcome == 'tie':
                winner_obj.update_player([loser_obj.rating], [loser_obj.rd], [0.5]) # 0.5 = Tie
                loser_obj.update_player([winner_obj.rating], [winner_obj.rd], [0.5]) # 0.5 = Tie
            else:
                winner_obj.update_player([loser_obj.rating], [loser_obj.rd], [1.0]) # 1.0 = Win
                loser_obj.update_player([winner_obj.rating], [winner_obj.rd], [0.0]) # 0.0 = Loss

            winner_cache_entry['match_count'] += 1
            loser_cache_entry['match_count'] += 1

            ratings_history['winner_rating_post'][i] = winner_obj.rating
            ratings_history['loser_rating_post'][i] = loser_obj.rating
            ratings_history['winner_rd_post'][i] = winner_obj.rd
            ratings_history['loser_rd_post'][i] = loser_obj.rd
            ratings_history['winner_matches_played'][i] = winner_cache_entry['match_count']
            ratings_history['loser_matches_played'][i] = loser_cache_entry['match_count']

            ratings_history['winner_rating_delta'][i] = winner_obj.rating - winner_rating_pre
            ratings_history['loser_rating_delta'][i] = loser_obj.rating - loser_rating_pre

        
        except KeyError as e:
            ratings_history['documentCode'][i] = row.documentCode
            ratings_history['winner_rating_pre'][i] = np.nan
        except Exception as e:
            ratings_history['documentCode'][i] = row.documentCode
            ratings_history['winner_rating_pre'][i] = np.nan

    print(f"--- âœ… Glicko-2 Calculation Complete ---")
    
    results_df = pd.DataFrame(ratings_history)
    results_df = results_df.dropna(subset=['winner_rating_pre'])

    float_cols = [col for col in results_df.columns if results_df[col].dtype == np.float64]
    results_df[float_cols] = results_df[float_cols].round(2)
    
    id_cols = ['winnerId', 'loserId', 'winner_matches_played', 'loser_matches_played']
    results_df[id_cols] = results_df[id_cols].astype(int)

    # --- 4. NEW: DYNAMICALLY RENAME COLUMNS ---
    if info_string:
        suffix = f" ({info_string})"
        
        # Define metadata columns that should NOT be renamed
        metadata_cols = {
            'eventId', 'EventName', 'documentCode', 'matchDate', 
            'winnerId', 'winnerName', 'winnerCountry', 
            'loserId', 'loserName', 'loserCountry', 'Winner'
        }
        
        # Find all data columns (those not in metadata_cols)
        data_cols = [col for col in results_df.columns if col not in metadata_cols]
        
        # Create the rename dictionary
        rename_dict = {col: f"{col}{suffix}" for col in data_cols}
        
        results_df = results_df.rename(columns=rename_dict)
        print(f"âœ… Renamed data columns with suffix: {suffix}")

    return results_df

def get_final_player_stats(ratings_df: pd.DataFrame, info_string: str = "") -> pd.DataFrame:
    """
    Calculates final, max, and average Glicko-2 ratings for every player
    from the historical match ratings DataFrame.
    Final output columns are in camelCase.

    Args:
        ratings_df (pd.DataFrame): The DataFrame generated by calculate_glicko2_ratings.
        info_string (str, optional): A string to append to all non-metadata (data) columns. 
                                     Defaults to "".

    Returns:
        pd.DataFrame: A DataFrame indexed by playerId, showing aggregated career statistics.
    """
    print(f"--- ðŸ“Š Aggregating Final Player Statistics ({info_string or 'Default'}) ---")
    
    # --- 1. Define Suffix based on info_string ---
    suffix = f" ({info_string})" if info_string else ""

    # --- 2. Prepare data by stacking winner and loser columns ---
    
    # Define columns to select, now with the suffix
    winner_cols = [
        'winnerId', 'winnerName', 'winnerCountry', 'matchDate', 
        f'winner_rating_post{suffix}', f'winner_rating_pre{suffix}', 
        f'winner_rd_post{suffix}', f'winner_matches_played{suffix}'
    ]
    
    df_winner_role = ratings_df[winner_cols].rename(columns={
        'winnerId': 'playerId', 
        'winnerName': 'playerName', 
        'winnerCountry': 'playerCountry',
        f'winner_rating_post{suffix}': 'final_rating',
        f'winner_rating_pre{suffix}': 'pre_rating',
        f'winner_rd_post{suffix}': 'final_rd',
        f'winner_matches_played{suffix}': 'total_matches'
    })
    # --- ADDED: 'is_win' column ---
    df_winner_role['is_win'] = 1
    
    loser_cols = [
        'loserId', 'loserName', 'loserCountry', 'matchDate', 
        f'loser_rating_post{suffix}', f'loser_rating_pre{suffix}', 
        f'loser_rd_post{suffix}', f'loser_matches_played{suffix}'
    ]

    df_loser_role = ratings_df[loser_cols].rename(columns={
        'loserId': 'playerId', 
        'loserName': 'playerName', 
        'loserCountry': 'playerCountry',
        f'loser_rating_post{suffix}': 'final_rating',
        f'loser_rating_pre{suffix}': 'pre_rating',
        f'loser_rd_post{suffix}': 'final_rd',
        f'loser_matches_played{suffix}': 'total_matches'
    })
    # --- ADDED: 'is_win' column ---
    df_loser_role['is_win'] = 0
    
    df_stacked = pd.concat([df_winner_role, df_loser_role], ignore_index=True)

    # --- 3. Group and aggregate the statistics ---
    agg_funcs = {
        'pre_rating': ['mean', 'max', 'idxmax'],
        'final_rd': 'last',
        'total_matches': 'max',
        'is_win': 'sum',  # --- ADDED: Sum of wins ---
        'playerName': 'last', 
        'playerCountry': 'last',
        'matchDate': 'last', 
        'final_rating': 'last',
    }
    
    player_stats = df_stacked.groupby('playerId').agg(agg_funcs)
    
    player_stats.columns = [
        f'{col[0]}_{col[1]}' if col[1] != '' else col[0] 
        for col in player_stats.columns
    ]
    
    # --- 4. Extract the Date of Max Rating and Clean Dates ---
    max_rating_indices = player_stats['pre_rating_idxmax']
    player_stats['Rating_Max_Date'] = df_stacked.loc[max_rating_indices.values, 'matchDate'].values
    player_stats.drop(columns='pre_rating_idxmax', inplace=True)
    
    # --- 5. Final Cleanup and Naming (PascalCase) ---
    player_stats.rename(columns={
        'pre_rating_mean': 'Rating_Avg',
        'pre_rating_max': 'Rating_Max',
        'final_rating_last': 'Rating_Final',
        'final_rd_last': 'RD_Final',
        'total_matches_max': 'TotalMatches',
        'is_win_sum': 'TotalWins', # --- ADDED: Rename sum of wins ---
        'playerName_last': 'PlayerName',
        'playerCountry_last': 'PlayerCountry',
        'matchDate_last': 'Rating_Final_Date', 
    }, inplace=True)

    # --- ADDED: Calculate WinRate ---
    player_stats['WinRate'] = (
        (player_stats['TotalWins'] / player_stats['TotalMatches']) * 100
    ).fillna(0) # Handle potential 0/0 for players with 0 matches

    player_stats['Rating_Final_Date'] = player_stats['Rating_Final_Date'].str.split('T').str[0]
    player_stats['Rating_Max_Date'] = player_stats['Rating_Max_Date'].str.split('T').str[0]
    
    player_stats = player_stats.sort_values(by=['Rating_Final'], ascending=False)
    
    float_cols = [col for col in player_stats.columns if player_stats[col].dtype == np.float64]
    player_stats[float_cols] = player_stats[float_cols].round(2)
    
    # --- 6. Apply info_string Suffix ---
    if info_string:
        metadata_cols = {
            'playerId', 'PlayerName', 'PlayerCountry'
        }
        
        data_cols = [col for col in player_stats.columns if col not in metadata_cols]
        
        rename_dict = {col: f"{col}{suffix}" for col in data_cols}
        
        player_stats = player_stats.rename(columns=rename_dict)
        print(f"âœ… Renamed aggregated columns with suffix: {suffix}")

    # --- 7. Convert all columns to camelCase ---
    camel_case_rename_dict = {
        'PlayerName': 'playerName',
        'PlayerCountry': 'playerCountry',
        f'Rating_Final{suffix}': f'ratingFinal{suffix}',
        f'TotalMatches{suffix}': f'totalMatches{suffix}',
        f'TotalWins{suffix}': f'totalWins{suffix}',       # --- ADDED ---
        f'WinRate{suffix}': f'winRate{suffix}',         # --- ADDED ---
        f'Rating_Avg{suffix}': f'ratingAvg{suffix}',
        f'Rating_Max{suffix}': f'ratingMax{suffix}',
        f'Rating_Max_Date{suffix}': f'ratingMaxDate{suffix}',
        f'RD_Final{suffix}': f'rdFinal{suffix}',
        f'Rating_Final_Date{suffix}': f'ratingFinalDate{suffix}',
    }
    player_stats = player_stats.rename(columns=camel_case_rename_dict)
    
    # --- 8. Reorder Columns ---
    final_cols_order = [
        'playerId', 
        'playerName', 
        'playerCountry', 
        f'ratingFinal{suffix}', 
        f'totalMatches{suffix}', 
        f'totalWins{suffix}',     # --- ADDED ---
        f'winRate{suffix}',       # --- ADDED ---
        f'ratingAvg{suffix}', 
        f'ratingMax{suffix}', 
        f'ratingMaxDate{suffix}',
        f'rdFinal{suffix}',
        f'ratingFinalDate{suffix}',
    ]
    
    player_stats = player_stats.reset_index()[final_cols_order]
    
    print(f"âœ… Aggregation complete. Found {len(player_stats)} unique players with match history.")
    return player_stats